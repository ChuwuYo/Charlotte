---
interface Props {
	words: string[];
	typeSpeed?: number;
	deleteSpeed?: number;
	delay?: number;
	class?: string;
	cursor?: string;
	showCursor?: boolean;
	startDelay?: number; // 开始打字前的延迟（用于光标闪烁预热）
}

const {
	words = ["Hello World", "Welcome to Astro"],
	typeSpeed = 100,
	deleteSpeed = 50,
	delay = 2000,
	class: className = "",
	cursor = "|",
	showCursor = true,
	startDelay = 0,
} = Astro.props;

// 生成唯一 ID 以支持页面中多个打字机实例
const uniqueId = `typewriter-${Math.random().toString(36).slice(2, 11)}`;
---

<span class:list={["typewriter-wrapper", className]}>
	<span 
		id={uniqueId}
		class="typewriter-text" 
		data-words={JSON.stringify(words)} 
		data-type-speed={typeSpeed}
		data-delete-speed={deleteSpeed}
		data-delay={delay}
		data-start-delay={startDelay}
	></span>{showCursor && <span class="typewriter-cursor">{cursor}</span>}
</span>

<style>
	.typewriter-wrapper {
		display: inline;
		word-wrap: break-word;
		word-break: break-word;
	}

	.typewriter-text {
		display: inline;
	}

	.typewriter-cursor {
		display: inline;
		margin-left: 2px;
		animation: blink 1s step-end infinite;
		opacity: 1;
	}

	@keyframes blink {
		0%, 50% { opacity: 1; }
		50.01%, 100% { opacity: 0; }
	}
</style>

<script>
	class TypewriterEffect {
		// 时间配置常量（毫秒）
		private static readonly COMPLETE_EXTRA_DELAY = 2000; // 打字完成后额外停留时间
		private static readonly DELETE_PAUSE_DELAY = 2000;   // 删除完成后光标闪烁时间

		private element: HTMLElement;
		private words: string[];
		private shuffledIndices: number[] = []; // 洗牌后的索引数组
		private typeSpeed: number;
		private deleteSpeed: number;
		private delay: number;
		private startDelay: number;
		private currentText: string = '';
		private wordIndex: number = 0; // 当前在洗牌数组中的位置
		private isDeleting: boolean = false;
		private timeoutId: number | null = null;

		constructor(element: HTMLElement) {
			this.element = element;
			
			// 强制清空内容（防止 View Transitions 缓存导致闪现旧文本）
			this.element.textContent = '';
			
			// 从 DOM 属性读取配置
			try {
				this.words = JSON.parse(element.dataset.words || '[]');
				this.typeSpeed = parseInt(element.dataset.typeSpeed || '100');
				this.deleteSpeed = parseInt(element.dataset.deleteSpeed || '50');
				this.delay = parseInt(element.dataset.delay || '2000');
				this.startDelay = parseInt(element.dataset.startDelay || '0');
			} catch (error) {
				console.error('Typewriter: 配置解析失败', error);
				this.words = ['Error'];
				this.typeSpeed = 100;
				this.deleteSpeed = 50;
				this.delay = 2000;
				this.startDelay = 0;
			}

			if (this.words.length > 0) {
				// 初始化时洗牌一次
				this.shuffleWords();
				
				// 如果有启动延迟，先等待
				if (this.startDelay > 0) {
					this.timeoutId = window.setTimeout(() => this.tick(), this.startDelay);
				} else {
					this.tick();
				}
			}
		}

		// Fisher-Yates 洗牌算法
		private shuffleWords() {
			this.shuffledIndices = Array.from({ length: this.words.length }, (_, i) => i);
			for (let i = this.shuffledIndices.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[this.shuffledIndices[i], this.shuffledIndices[j]] = 
					[this.shuffledIndices[j], this.shuffledIndices[i]];
			}
		}

		// 检测字符是否为中文、日文或韩文
		private isCJKCharacter(char: string): boolean {
			const code = char.charCodeAt(0);
			return (
				(code >= 0x4E00 && code <= 0x9FFF) ||
				(code >= 0x3400 && code <= 0x4DBF) ||
				(code >= 0x20000 && code <= 0x2A6DF) ||
				(code >= 0x2A700 && code <= 0x2B73F) ||
				(code >= 0x2B740 && code <= 0x2B81F) ||
				(code >= 0x2B820 && code <= 0x2CEAF) ||
				(code >= 0x3040 && code <= 0x309F) ||
				(code >= 0x30A0 && code <= 0x30FF) ||
				(code >= 0xAC00 && code <= 0xD7AF)
			);
		}

		// 获取当前字符的打字速度（中文字符使用更长的间隔）
		private getTypeSpeed(char: string): number {
			return this.isCJKCharacter(char) ? this.typeSpeed * 2 : this.typeSpeed;
		}

		// 获取当前字符的删除速度
		private getDeleteSpeed(char: string): number {
			return this.isCJKCharacter(char) ? this.deleteSpeed * 2 : this.deleteSpeed;
		}

		// 触发自定义事件
		private dispatchEvent(eventName: string, detail: any = {}) {
			const event = new CustomEvent(eventName, { 
				detail,
				bubbles: true,
				composed: true
			});
			this.element.dispatchEvent(event);
		}

		private tick() {
			// 获取当前在洗牌数组中的位置
			const currentPosition = this.wordIndex % this.shuffledIndices.length;
			// 通过洗牌索引获取实际的文本索引
			const actualIndex = this.shuffledIndices[currentPosition];
			const fullText = this.words[actualIndex];

			// 状态 1: 打字中
			if (!this.isDeleting && this.currentText.length < fullText.length) {
				this.currentText = fullText.substring(0, this.currentText.length + 1);
				this.element.textContent = this.currentText;
				
				// 获取刚打出的字符的速度
				const lastChar = this.currentText[this.currentText.length - 1];
				const speed = this.getTypeSpeed(lastChar);
				
				this.timeoutId = window.setTimeout(() => this.tick(), speed);
			} 
			// 状态 2: 打字完成 - 停留并触发事件
			else if (!this.isDeleting && this.currentText === fullText) {
				// 触发打字完成事件，传递实际的文本索引
				this.dispatchEvent('typewriter:complete', { 
					text: fullText, 
					index: actualIndex 
				});
				
				this.isDeleting = true;
				this.timeoutId = window.setTimeout(() => this.tick(), this.delay + TypewriterEffect.COMPLETE_EXTRA_DELAY);
			} 
			// 状态 3: 删除中
			else if (this.isDeleting && this.currentText.length > 0) {
				const charToDelete = this.currentText[this.currentText.length - 1];
				this.currentText = fullText.substring(0, this.currentText.length - 1);
				this.element.textContent = this.currentText;
				
				const speed = this.getDeleteSpeed(charToDelete);
				this.timeoutId = window.setTimeout(() => this.tick(), speed);
			} 
			// 状态 4: 删除完成 - 切换到下一个单词并触发事件
			else if (this.isDeleting && this.currentText === '') {
				this.isDeleting = false;
				this.wordIndex++;
				
				// 检查是否完成一轮（到达洗牌数组的末尾）
				if (this.wordIndex % this.shuffledIndices.length === 0) {
					// 重新洗牌，开始新一轮
					this.shuffleWords();
				}
				
				// 获取下一个位置的实际索引
				const nextPosition = this.wordIndex % this.shuffledIndices.length;
				const nextActualIndex = this.shuffledIndices[nextPosition];
				
				// 触发删除完成事件
				this.dispatchEvent('typewriter:deleted', { 
					nextIndex: nextActualIndex 
				});
				
				this.timeoutId = window.setTimeout(() => this.tick(), TypewriterEffect.DELETE_PAUSE_DELAY);
			}
		}

		public destroy() {
			if (this.timeoutId) {
				clearTimeout(this.timeoutId);
				this.timeoutId = null;
			}
		}
	}

	function initTypewriters() {
		const elements = document.querySelectorAll<HTMLElement>('.typewriter-text');
		elements.forEach(el => {
			if (!(el as any).__typewriter) {
				(el as any).__typewriter = new TypewriterEffect(el);
			}
		});
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initTypewriters);
	} else {
		initTypewriters();
	}

	// 支持 Astro 页面切换（View Transitions）
	document.addEventListener('astro:page-load', initTypewriters);

	// 在页面切换前清理所有打字机实例
	document.addEventListener('astro:before-swap', () => {
		document.querySelectorAll<HTMLElement>('.typewriter-text').forEach(el => {
			if ((el as any).__typewriter) {
				(el as any).__typewriter.destroy();
				delete (el as any).__typewriter;
			}
		});
	});
</script>
